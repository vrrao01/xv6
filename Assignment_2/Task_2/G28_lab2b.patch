diff -uN xv6-public/console.c os-lab/console.c
--- xv6-public/console.c	2021-10-09 22:56:09.965447862 +0530
+++ os-lab/console.c	2021-09-30 23:22:45.847750650 +0530
@@ -19,7 +19,8 @@
 
 static int panicked = 0;
 
-static struct {
+static struct
+{
   struct spinlock lock;
   int locking;
 } cons;
@@ -32,49 +33,52 @@
   int i;
   uint x;
 
-  if(sign && (sign = xx < 0))
+  if (sign && (sign = xx < 0))
     x = -xx;
   else
     x = xx;
 
   i = 0;
-  do{
+  do
+  {
     buf[i++] = digits[x % base];
-  }while((x /= base) != 0);
+  } while ((x /= base) != 0);
 
-  if(sign)
+  if (sign)
     buf[i++] = '-';
 
-  while(--i >= 0)
+  while (--i >= 0)
     consputc(buf[i]);
 }
 //PAGEBREAK: 50
 
 // Print to the console. only understands %d, %x, %p, %s.
-void
-cprintf(char *fmt, ...)
+void cprintf(char *fmt, ...)
 {
   int i, c, locking;
   uint *argp;
   char *s;
 
   locking = cons.locking;
-  if(locking)
+  if (locking)
     acquire(&cons.lock);
 
   if (fmt == 0)
     panic("null fmt");
 
-  argp = (uint*)(void*)(&fmt + 1);
-  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
-    if(c != '%'){
+  argp = (uint *)(void *)(&fmt + 1);
+  for (i = 0; (c = fmt[i] & 0xff) != 0; i++)
+  {
+    if (c != '%')
+    {
       consputc(c);
       continue;
     }
     c = fmt[++i] & 0xff;
-    if(c == 0)
+    if (c == 0)
       break;
-    switch(c){
+    switch (c)
+    {
     case 'd':
       printint(*argp++, 10, 1);
       break;
@@ -83,9 +87,9 @@
       printint(*argp++, 16, 0);
       break;
     case 's':
-      if((s = (char*)*argp++) == 0)
+      if ((s = (char *)*argp++) == 0)
         s = "(null)";
-      for(; *s; s++)
+      for (; *s; s++)
         consputc(*s);
       break;
     case '%':
@@ -99,12 +103,11 @@
     }
   }
 
-  if(locking)
+  if (locking)
     release(&cons.lock);
 }
 
-void
-panic(char *s)
+void panic(char *s)
 {
   int i;
   uint pcs[10];
@@ -116,18 +119,22 @@
   cprintf(s);
   cprintf("\n");
   getcallerpcs(&s, pcs);
-  for(i=0; i<10; i++)
+  for (i = 0; i < 10; i++)
     cprintf(" %p", pcs[i]);
   panicked = 1; // freeze other CPU
-  for(;;)
+  for (;;)
     ;
 }
 
 //PAGEBREAK: 50
 #define BACKSPACE 0x100
+#define LEFT_ARROW 228
+#define RIGHT_ARROW 229
+#define UP_ARROW 226
+#define DOWN_ARROW 227
 #define CRTPORT 0x3d4
-static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
-
+static ushort *crt = (ushort *)P2V(0xb8000); // CGA memory
+int max_pos = 0;                             // Position of rightmost character
 static void
 cgaputc(int c)
 {
@@ -135,91 +142,388 @@
 
   // Cursor position: col + 80*row.
   outb(CRTPORT, 14);
-  pos = inb(CRTPORT+1) << 8;
+  pos = inb(CRTPORT + 1) << 8;
   outb(CRTPORT, 15);
-  pos |= inb(CRTPORT+1);
+  pos |= inb(CRTPORT + 1);
 
-  if(c == '\n')
-    pos += 80 - pos%80;
-  else if(c == BACKSPACE){
-    if(pos > 0) --pos;
-  } else
-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+  if (c == '\n')
+    pos += 80 - pos % 80;
+  else if (c == BACKSPACE)
+  {
+    /*
+    Ensure the cursor is not at the leftmost position and
+    appropriate shift the characters to the left. 
+    */
+    if (pos > 0)
+    {
+      --pos;
+      for (int t = pos; t < max_pos; t++)
+        crt[t] = ((crt[t + 1] & 0xff) | 0x0700);
+      crt[max_pos] = ' ' | 0x0700;
+      --max_pos;
+    }
+  }
 
-  if(pos < 0 || pos > 25*80)
+  else if (c == LEFT_ARROW)
+  {
+    --pos; // Move cursor to the left
+  }
+  else if (c == RIGHT_ARROW)
+  {
+    ++pos; // Move cursor to the right
+  }
+  else
+  {
+    /* 
+    Print entered character onto the screen. 
+    Also, shift right in case entered character is in the middle.
+    */
+    for (int t = max_pos; t >= pos; t--)
+      crt[t + 1] = ((crt[t] & 0xff) | 0x0700);
+    max_pos++;
+    if (pos > max_pos)
+      max_pos = pos;
+    crt[pos++] = (c & 0xff) | 0x0700; // black on white
+  }
+
+  if (pos < 0 || pos > 25 * 80)
     panic("pos under/overflow");
 
-  if((pos/80) >= 24){  // Scroll up.
-    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+  if ((pos / 80) >= 24)
+  { // Scroll up.
+    memmove(crt, crt + 80, sizeof(crt[0]) * 23 * 80);
     pos -= 80;
-    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+    memset(crt + pos, 0, sizeof(crt[0]) * (24 * 80 - pos));
   }
 
   outb(CRTPORT, 14);
-  outb(CRTPORT+1, pos>>8);
+  outb(CRTPORT + 1, pos >> 8);
   outb(CRTPORT, 15);
-  outb(CRTPORT+1, pos);
-  crt[pos] = ' ' | 0x0700;
+  outb(CRTPORT + 1, pos);
 }
 
-void
-consputc(int c)
+#define INPUT_BUF 128
+#define MAX_HISTORY 16
+struct
 {
-  if(panicked){
+  char buf[INPUT_BUF];
+  uint r; // Read index
+  uint w; // Write index
+  uint e; // Edit index
+  uint m; // Rightmost character index
+} input;
+
+/*
+Shell history ring structure
+*/
+struct
+{
+  char buffer[MAX_HISTORY][INPUT_BUF]; // 2D array to store commands
+  int head;                            // Head of the queue
+  int tail;                            // Tail of the queue
+  int currentIndex;                    // Index of current command from history being viewed
+  char partialBuffer[INPUT_BUF];       // Buffer to store command typed before accessing history
+} historyRing;
+
+void consputc(int c)
+{
+  if (panicked)
+  {
     cli();
-    for(;;)
+    for (;;)
       ;
   }
 
-  if(c == BACKSPACE){
-    uartputc('\b'); uartputc(' '); uartputc('\b');
-  } else
-    uartputc(c);
+  if (c == RIGHT_ARROW)
+  {
+    uartputc(input.buf[input.e]);
+    cgaputc(c);
+    return;
+  }
+
+  if (c == LEFT_ARROW)
+  {
+    uartputc('\b');
+    cgaputc(c);
+    return;
+  }
+  if (c == BACKSPACE)
+  {
+    uartputc('\b');
+    /*
+    Shift all characters to the right of cursor, one position to the left.
+    */
+    for (uint t = input.e; t < input.m; t++)
+    {
+      uartputc(input.buf[t + 1]);
+      input.buf[t] = input.buf[t + 1];
+    }
+    uartputc(' ');
+    uartputc('\b');
+    /*
+    Move serial port cursor to correct edit position.
+    */
+    for (uint t = input.e; t < input.m; t++)
+    {
+      uartputc('\b');
+    }
+  }
+  else
+  {
+    if (input.e < input.m)
+    {
+      char fill, temp;
+      fill = c;
+      for (int i = input.e; i <= input.m; i++)
+      {
+        temp = input.buf[i % INPUT_BUF];
+        uartputc(fill);
+        fill = temp;
+      }
+      for (int i = input.e; i < input.m; i++)
+      {
+        uartputc('\b');
+      }
+    }
+    else
+    {
+      uartputc(c);
+    }
+  }
+
   cgaputc(c);
 }
 
-#define INPUT_BUF 128
-struct {
-  char buf[INPUT_BUF];
-  uint r;  // Read index
-  uint w;  // Write index
-  uint e;  // Edit index
-} input;
+/*
+Removes the line of text currently display on the console.
+*/
+void clearConsoleLine()
+{
+  for (int i = input.e; i < input.m; i++)
+  {
+    consputc(RIGHT_ARROW); // Moves cursor to rightmost position
+  }
+  for (int i = input.r; i < input.m; i++)
+  {
+    uartputc('\b');
+    uartputc(' ');
+    uartputc('\b');
+    cgaputc(BACKSPACE);
+    // consputc(BACKSPACE); // Clears text by repeated BACKSPACEs
+  }
+}
 
-#define C(x)  ((x)-'@')  // Control-x
+/*
+Resets input buffer in order to fill command from history 
+*/
+void clearInputBufferLine()
+{
+  input.m = input.r;
+  input.e = input.r;
+}
 
-void
-consoleintr(int (*getc)(void))
+/*
+Copy command at index history.currentIndex into the input buffer
+*/
+void copyHistorytoInputBuffer()
 {
-  int c, doprocdump = 0;
+  for (int i = 0; i < INPUT_BUF; i++)
+  {
+    if (historyRing.buffer[historyRing.currentIndex][i] == 0)
+      break;
+    input.buf[(input.r + i) % INPUT_BUF] = historyRing.buffer[historyRing.currentIndex][i];
+    input.e++;
+    input.m++;
+  }
+}
 
+/*
+Copies the command entered before pressing on up arrow into a temporary buffer
+*/
+void savePartialCommand()
+{
+  memset(historyRing.partialBuffer, 0, INPUT_BUF);
+  for (int i = input.r; i < input.m; i++)
+  {
+    historyRing.partialBuffer[i - input.r] = input.buf[i % INPUT_BUF];
+  }
+}
+
+/*
+Copies the command typed before accessing history back into input buffer
+*/
+void copyPartialToInputBuffer()
+{
+  for (int i = 0; i < INPUT_BUF; i++)
+  {
+    if (historyRing.partialBuffer[i] == 0)
+      break;
+    input.buf[(input.r + i) % INPUT_BUF] = historyRing.partialBuffer[i];
+    input.e++;
+    input.m++;
+  }
+}
+
+/*
+Stores the entered command into the history shell ring.
+*/
+void saveHistory()
+{
+  if (historyRing.buffer[historyRing.head][0] == 0)
+  {
+    int length = input.m - input.r;
+    for (int i = 0; i < length; i++)
+    {
+      historyRing.buffer[historyRing.tail][i] = input.buf[(input.r + i) % INPUT_BUF];
+    }
+  }
+  else
+  {
+    historyRing.tail = (historyRing.tail + 1) % MAX_HISTORY;
+    if (historyRing.tail == historyRing.head)
+      historyRing.head = (historyRing.head + 1) % MAX_HISTORY;
+    int length = input.m - input.r;
+    memset(historyRing.buffer[historyRing.tail], 0, INPUT_BUF);
+    for (int i = 0; i < length; i++)
+    {
+      historyRing.buffer[historyRing.tail][i] = input.buf[(input.r + i) % INPUT_BUF];
+    }
+  }
+  historyRing.currentIndex = -1;
+}
+
+/*
+Function used by sys_history system call to copy command at index = historyID into buffer
+*/
+int history(char *buffer, int historyID)
+{
+  if (historyID < 0 || historyID > 15)
+    return 2;
+  int index = (historyRing.head + historyID) % MAX_HISTORY;
+  if (historyRing.buffer[index][0] == 0)
+    return 1;
+  memmove(buffer, historyRing.buffer[index], INPUT_BUF);
+  return 0;
+}
+#define C(x) ((x) - '@') // Control-x
+
+void consoleintr(int (*getc)(void))
+{
+  int c, doprocdump = 0;
+  // uint tempIndex;
   acquire(&cons.lock);
-  while((c = getc()) >= 0){
-    switch(c){
-    case C('P'):  // Process listing.
+  while ((c = getc()) >= 0)
+  {
+    if (input.m < input.e)
+      input.m = input.e;
+    switch (c)
+    {
+    case C('P'): // Process listing.
       // procdump() locks cons.lock indirectly; invoke later
       doprocdump = 1;
       break;
-    case C('U'):  // Kill line.
-      while(input.e != input.w &&
-            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+    case C('U'): // Kill line.
+      while (input.e != input.w &&
+             input.buf[(input.e - 1) % INPUT_BUF] != '\n')
+      {
         input.e--;
         consputc(BACKSPACE);
       }
       break;
-    case C('H'): case '\x7f':  // Backspace
-      if(input.e != input.w){
+    case C('H'):
+    case '\x7f': // Backspace
+      if (input.e != input.w)
+      {
+        input.m--;
         input.e--;
         consputc(BACKSPACE);
       }
       break;
+    case LEFT_ARROW:
+      if (input.e != input.w)
+      {
+        input.e--;
+        consputc(c);
+      }
+      break;
+
+    case RIGHT_ARROW:
+      if (input.e != input.m)
+      {
+        consputc(c);
+        input.e++;
+      }
+      break;
+
+    case UP_ARROW:
+      if (historyRing.buffer[historyRing.head][0] != 0)
+      {
+        clearConsoleLine();
+        if (historyRing.currentIndex == -1)
+        {
+          historyRing.currentIndex = historyRing.tail;
+          savePartialCommand();
+        }
+        else if (historyRing.currentIndex != historyRing.head)
+          historyRing.currentIndex = (historyRing.currentIndex + MAX_HISTORY - 1) % MAX_HISTORY;
+        clearInputBufferLine();
+        release(&cons.lock); // Release console lock so that cprint can aquire lock
+        cprintf(historyRing.buffer[historyRing.currentIndex]);
+        acquire(&cons.lock);
+        copyHistorytoInputBuffer();
+      }
+      break;
+    case DOWN_ARROW:
+      if (historyRing.buffer[historyRing.head][0] != 0)
+      {
+        if (historyRing.currentIndex == historyRing.tail)
+        {
+          historyRing.currentIndex = -1;
+          clearConsoleLine();
+          clearInputBufferLine();
+          release(&cons.lock);
+          cprintf(historyRing.partialBuffer);
+          acquire(&cons.lock);
+          copyPartialToInputBuffer();
+        }
+        else if (historyRing.currentIndex != -1)
+        {
+          historyRing.currentIndex = (historyRing.currentIndex + 1) % MAX_HISTORY;
+          clearConsoleLine();
+          clearInputBufferLine();
+          copyHistorytoInputBuffer();
+          release(&cons.lock);
+          cprintf(historyRing.buffer[historyRing.currentIndex]);
+          acquire(&cons.lock);
+        }
+      }
+      break;
     default:
-      if(c != 0 && input.e-input.r < INPUT_BUF){
+      if (c != 0 && input.e - input.r < INPUT_BUF)
+      {
         c = (c == '\r') ? '\n' : c;
+        if (c == '\n' || c == C('D') || input.e == input.r + INPUT_BUF)
+        {
+          input.e = input.m; // Move edit index to rightmost index to execute command
+        }
+        if (input.e < input.m)
+        {
+          /*
+          Shift right input buffer  in case character is not added at rightmost position.
+          */
+          int n = input.m - input.e;
+          for (int i = n; i > 0; i--)
+          {
+            input.buf[(input.e + i) % INPUT_BUF] = input.buf[(input.e + i - 1) % INPUT_BUF];
+          }
+          input.m++;
+        }
         input.buf[input.e++ % INPUT_BUF] = c;
         consputc(c);
-        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+        if (c == '\n' || c == C('D') || input.e == input.r + INPUT_BUF)
+        {
           input.w = input.e;
+          saveHistory();
           wakeup(&input.r);
         }
       }
@@ -227,13 +531,13 @@
     }
   }
   release(&cons.lock);
-  if(doprocdump) {
-    procdump();  // now call procdump() wo. cons.lock held
+  if (doprocdump)
+  {
+    procdump(); // now call procdump() wo. cons.lock held
   }
 }
 
-int
-consoleread(struct inode *ip, char *dst, int n)
+int consoleread(struct inode *ip, char *dst, int n)
 {
   uint target;
   int c;
@@ -241,9 +545,12 @@
   iunlock(ip);
   target = n;
   acquire(&cons.lock);
-  while(n > 0){
-    while(input.r == input.w){
-      if(myproc()->killed){
+  while (n > 0)
+  {
+    while (input.r == input.w)
+    {
+      if (myproc()->killed)
+      {
         release(&cons.lock);
         ilock(ip);
         return -1;
@@ -251,8 +558,10 @@
       sleep(&input.r, &cons.lock);
     }
     c = input.buf[input.r++ % INPUT_BUF];
-    if(c == C('D')){  // EOF
-      if(n < target){
+    if (c == C('D'))
+    { // EOF
+      if (n < target)
+      {
         // Save ^D for next time, to make sure
         // caller gets a 0-byte result.
         input.r--;
@@ -261,7 +570,7 @@
     }
     *dst++ = c;
     --n;
-    if(c == '\n')
+    if (c == '\n')
       break;
   }
   release(&cons.lock);
@@ -270,14 +579,13 @@
   return target - n;
 }
 
-int
-consolewrite(struct inode *ip, char *buf, int n)
+int consolewrite(struct inode *ip, char *buf, int n)
 {
   int i;
 
   iunlock(ip);
   acquire(&cons.lock);
-  for(i = 0; i < n; i++)
+  for (i = 0; i < n; i++)
     consputc(buf[i] & 0xff);
   release(&cons.lock);
   ilock(ip);
@@ -285,8 +593,7 @@
   return n;
 }
 
-void
-consoleinit(void)
+void consoleinit(void)
 {
   initlock(&cons.lock, "console");
 
@@ -295,5 +602,4 @@
   cons.locking = 1;
 
   ioapicenable(IRQ_KBD, 0);
-}
-
+}
\ No newline at end of file
diff -uN xv6-public/defs.h os-lab/defs.h
--- xv6-public/defs.h	2021-10-09 22:56:09.965447862 +0530
+++ os-lab/defs.h	2021-09-30 23:22:45.847750650 +0530
@@ -21,6 +21,7 @@
 void            cprintf(char*, ...);
 void            consoleintr(int(*)(void));
 void            panic(char*) __attribute__((noreturn));
+int             history(char*,int);
 
 // exec.c
 int             exec(char*, char**);
@@ -118,8 +119,10 @@
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
 int             wait(void);
+int             wait2(int*, int*, int*);
 void            wakeup(void*);
 void            yield(void);
+int             set_prio(int);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff -uN xv6-public/exec.c os-lab/exec.c
--- xv6-public/exec.c	2021-10-09 22:56:09.965447862 +0530
+++ os-lab/exec.c	2021-09-30 23:22:45.851750594 +0530
@@ -7,12 +7,11 @@
 #include "x86.h"
 #include "elf.h"
 
-int
-exec(char *path, char **argv)
+int exec(char *path, char **argv)
 {
   char *s, *last;
   int i, off;
-  uint argc, sz, sp, ustack[3+MAXARG+1];
+  uint argc, sz, sp, ustack[3 + MAXARG + 1];
   struct elfhdr elf;
   struct inode *ip;
   struct proghdr ph;
@@ -21,7 +20,8 @@
 
   begin_op();
 
-  if((ip = namei(path)) == 0){
+  if ((ip = namei(path)) == 0)
+  {
     end_op();
     cprintf("exec: fail\n");
     return -1;
@@ -30,30 +30,31 @@
   pgdir = 0;
 
   // Check ELF header
-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
+  if (readi(ip, (char *)&elf, 0, sizeof(elf)) != sizeof(elf))
     goto bad;
-  if(elf.magic != ELF_MAGIC)
+  if (elf.magic != ELF_MAGIC)
     goto bad;
 
-  if((pgdir = setupkvm()) == 0)
+  if ((pgdir = setupkvm()) == 0)
     goto bad;
 
   // Load program into memory.
   sz = 0;
-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
-    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+  for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph))
+  {
+    if (readi(ip, (char *)&ph, off, sizeof(ph)) != sizeof(ph))
       goto bad;
-    if(ph.type != ELF_PROG_LOAD)
+    if (ph.type != ELF_PROG_LOAD)
       continue;
-    if(ph.memsz < ph.filesz)
+    if (ph.memsz < ph.filesz)
       goto bad;
-    if(ph.vaddr + ph.memsz < ph.vaddr)
+    if (ph.vaddr + ph.memsz < ph.vaddr)
       goto bad;
-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+    if ((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
       goto bad;
-    if(ph.vaddr % PGSIZE != 0)
+    if (ph.vaddr % PGSIZE != 0)
       goto bad;
-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+    if (loaduvm(pgdir, (char *)ph.vaddr, ip, ph.off, ph.filesz) < 0)
       goto bad;
   }
   iunlockput(ip);
@@ -63,50 +64,55 @@
   // Allocate two pages at the next page boundary.
   // Make the first inaccessible.  Use the second as the user stack.
   sz = PGROUNDUP(sz);
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+  if ((sz = allocuvm(pgdir, sz, sz + 2 * PGSIZE)) == 0)
     goto bad;
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+  clearpteu(pgdir, (char *)(sz - 2 * PGSIZE));
   sp = sz;
 
   // Push argument strings, prepare rest of stack in ustack.
-  for(argc = 0; argv[argc]; argc++) {
-    if(argc >= MAXARG)
+  for (argc = 0; argv[argc]; argc++)
+  {
+    if (argc >= MAXARG)
       goto bad;
     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+    if (copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
       goto bad;
-    ustack[3+argc] = sp;
+    ustack[3 + argc] = sp;
   }
-  ustack[3+argc] = 0;
+  ustack[3 + argc] = 0;
 
-  ustack[0] = 0xffffffff;  // fake return PC
+  ustack[0] = 0xffffffff; // fake return PC
   ustack[1] = argc;
-  ustack[2] = sp - (argc+1)*4;  // argv pointer
+  ustack[2] = sp - (argc + 1) * 4; // argv pointer
 
-  sp -= (3+argc+1) * 4;
-  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+  sp -= (3 + argc + 1) * 4;
+  if (copyout(pgdir, sp, ustack, (3 + argc + 1) * 4) < 0)
     goto bad;
 
   // Save program name for debugging.
-  for(last=s=path; *s; s++)
-    if(*s == '/')
-      last = s+1;
+  for (last = s = path; *s; s++)
+    if (*s == '/')
+      last = s + 1;
   safestrcpy(curproc->name, last, sizeof(curproc->name));
 
   // Commit to the user image.
   oldpgdir = curproc->pgdir;
   curproc->pgdir = pgdir;
   curproc->sz = sz;
-  curproc->tf->eip = elf.entry;  // main
+  curproc->tf->eip = elf.entry; // main
   curproc->tf->esp = sp;
+#ifdef DML
+  curproc->priority = 2; // Default priority
+#endif
   switchuvm(curproc);
   freevm(oldpgdir);
   return 0;
 
- bad:
-  if(pgdir)
+bad:
+  if (pgdir)
     freevm(pgdir);
-  if(ip){
+  if (ip)
+  {
     iunlockput(ip);
     end_op();
   }
Common subdirectories: xv6-public/.git and os-lab/.git
diff -uN xv6-public/.gitignore os-lab/.gitignore
--- xv6-public/.gitignore	2021-10-09 22:56:09.965447862 +0530
+++ os-lab/.gitignore	2021-09-30 23:22:45.847750650 +0530
@@ -14,3 +14,4 @@
 kernelmemfs
 mkfs
 .gdbinit
+.vscode
\ No newline at end of file
diff -uN xv6-public/history.c os-lab/history.c
--- xv6-public/history.c	1970-01-01 05:30:00.000000000 +0530
+++ os-lab/history.c	2021-09-30 23:22:45.851750594 +0530
@@ -0,0 +1,23 @@
+#include "types.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+    char buffer[128];
+    int hasHistory;
+    for (int i = 0; i < 16; i++)
+    {
+        memset(buffer, 0, 128);
+        if (history(buffer, i) != 0)
+        {
+            break;
+        }
+        hasHistory = 1;
+        printf(1, "%d : %s\n", i, buffer);
+    }
+    if (hasHistory == 0)
+    {
+        printf(1, "No history available \n");
+    }
+    exit();
+}
diff -uN xv6-public/Makefile os-lab/Makefile
--- xv6-public/Makefile	2021-10-09 22:56:09.965447862 +0530
+++ os-lab/Makefile	2021-09-30 23:22:45.847750650 +0530
@@ -74,9 +74,10 @@
 CC = $(TOOLPREFIX)gcc
 AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
+SCHEDFLAG = DEFAULT
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -D $(SCHEDFLAG)
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
@@ -181,6 +182,10 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_history\
+	_wait2\
+	_sanity\
+	_SMLSanity\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +222,7 @@
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -248,7 +253,7 @@
 # check in that version.
 
 EXTRA=\
-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c sanity.c SMLSanity.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
diff -uN xv6-public/param.h os-lab/param.h
--- xv6-public/param.h	2021-10-09 22:56:09.965447862 +0530
+++ os-lab/param.h	2021-09-30 23:22:45.855750540 +0530
@@ -11,4 +11,5 @@
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       1000  // size of file system in blocks
+#define QUANTA       5 //Number of clock ticks given to process before pre-emption
 
diff -uN xv6-public/proc.c os-lab/proc.c
--- xv6-public/proc.c	2021-10-09 22:56:09.969447734 +0530
+++ os-lab/proc.c	2021-10-09 22:51:50.310846742 +0530
@@ -7,9 +7,12 @@
 #include "proc.h"
 #include "spinlock.h"
 
-struct {
+struct
+{
   struct spinlock lock;
   struct proc proc[NPROC];
+  struct proc *priorityLevels[3][NPROC];
+  int queueTails[3];
 } ptable;
 
 static struct proc *initproc;
@@ -20,32 +23,36 @@
 
 static void wakeup1(void *chan);
 
-void
-pinit(void)
+void pinit(void)
 {
   initlock(&ptable.lock, "ptable");
+  // Initialise tail pointers
+  ptable.queueTails[0] = -1;
+  ptable.queueTails[1] = -1;
+  ptable.queueTails[2] = -1;
 }
 
 // Must be called with interrupts disabled
-int
-cpuid() {
-  return mycpu()-cpus;
+int cpuid()
+{
+  return mycpu() - cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
-struct cpu*
+struct cpu *
 mycpu(void)
 {
   int apicid, i;
-  
-  if(readeflags()&FL_IF)
+
+  if (readeflags() & FL_IF)
     panic("mycpu called with interrupts enabled\n");
-  
+
   apicid = lapicid();
   // APIC IDs are not guaranteed to be contiguous. Maybe we should have
   // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
+  for (i = 0; i < ncpu; ++i)
+  {
     if (cpus[i].apicid == apicid)
       return &cpus[i];
   }
@@ -54,8 +61,9 @@
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
-struct proc*
-myproc(void) {
+struct proc *
+myproc(void)
+{
   struct cpu *c;
   struct proc *p;
   pushcli();
@@ -70,7 +78,7 @@
 // If found, change state to EMBRYO and initialize
 // state required to run in the kernel.
 // Otherwise return 0.
-static struct proc*
+static struct proc *
 allocproc(void)
 {
   struct proc *p;
@@ -78,8 +86,8 @@
 
   acquire(&ptable.lock);
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == UNUSED)
       goto found;
 
   release(&ptable.lock);
@@ -88,11 +96,17 @@
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
+  p->ctime = ticks;
+  p->retime = 0;
+  p->rutime = 0;
+  p->stime = 0;
+  p->priority = 0;
 
   release(&ptable.lock);
 
   // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
+  if ((p->kstack = kalloc()) == 0)
+  {
     p->state = UNUSED;
     return 0;
   }
@@ -100,15 +114,15 @@
 
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
+  p->tf = (struct trapframe *)sp;
 
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
-  *(uint*)sp = (uint)trapret;
+  *(uint *)sp = (uint)trapret;
 
   sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
+  p->context = (struct context *)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
@@ -117,19 +131,20 @@
 
 //PAGEBREAK: 32
 // Set up first user process.
-void
-userinit(void)
+void userinit(void)
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
+
   initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
+  if ((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
   p->sz = PGSIZE;
+  p->ctime = ticks;
+  p->priority = 2; // Initial process has priority = 2
   memset(p->tf, 0, sizeof(*p->tf));
   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
@@ -137,7 +152,7 @@
   p->tf->ss = p->tf->ds;
   p->tf->eflags = FL_IF;
   p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
+  p->tf->eip = 0; // beginning of initcode.S
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
@@ -147,26 +162,31 @@
   // writes to be visible, and the lock is also needed
   // because the assignment might not be atomic.
   acquire(&ptable.lock);
-
   p->state = RUNNABLE;
+#if defined SML || defined DML
+  ptable.queueTails[p->priority - 1]++;
+  ptable.priorityLevels[p->priority - 1][ptable.queueTails[p->priority - 1]] = p;
+#endif
 
   release(&ptable.lock);
 }
 
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
-int
-growproc(int n)
+int growproc(int n)
 {
   uint sz;
   struct proc *curproc = myproc();
 
   sz = curproc->sz;
-  if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  if (n > 0)
+  {
+    if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  }
+  else if (n < 0)
+  {
+    if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
   }
   curproc->sz = sz;
@@ -177,20 +197,21 @@
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
-int
-fork(void)
+int fork(void)
 {
   int i, pid;
   struct proc *np;
   struct proc *curproc = myproc();
 
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if ((np = allocproc()) == 0)
+  {
     return -1;
   }
 
   // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+  if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0)
+  {
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
@@ -202,9 +223,9 @@
 
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
-
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
+  np->priority = curproc->priority; // Child inherits parent's priority
+  for (i = 0; i < NOFILE; i++)
+    if (curproc->ofile[i])
       np->ofile[i] = filedup(curproc->ofile[i]);
   np->cwd = idup(curproc->cwd);
 
@@ -215,7 +236,10 @@
   acquire(&ptable.lock);
 
   np->state = RUNNABLE;
-
+#if defined SML || defined DML
+  ptable.queueTails[np->priority - 1]++;
+  ptable.priorityLevels[np->priority - 1][ptable.queueTails[np->priority - 1]] = np;
+#endif
   release(&ptable.lock);
 
   return pid;
@@ -224,19 +248,20 @@
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void
-exit(void)
+void exit(void)
 {
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
 
-  if(curproc == initproc)
+  if (curproc == initproc)
     panic("init exiting");
 
   // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
+  for (fd = 0; fd < NOFILE; fd++)
+  {
+    if (curproc->ofile[fd])
+    {
       fileclose(curproc->ofile[fd]);
       curproc->ofile[fd] = 0;
     }
@@ -253,10 +278,12 @@
   wakeup1(curproc->parent);
 
   // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->parent == curproc)
+    {
       p->parent = initproc;
-      if(p->state == ZOMBIE)
+      if (p->state == ZOMBIE)
         wakeup1(initproc);
     }
   }
@@ -269,22 +296,73 @@
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(void)
+int wait(void)
+{
+  struct proc *p;
+  int havekids, pid;
+  struct proc *curproc = myproc();
+
+  acquire(&ptable.lock);
+  for (;;)
+  {
+    // Scan through table looking for exited children.
+    havekids = 0;
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->parent != curproc)
+        continue;
+      havekids = 1;
+      if (p->state == ZOMBIE)
+      {
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        p->state = UNUSED;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if (!havekids || curproc->killed)
+    {
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(curproc, &ptable.lock); //DOC: wait-sleep
+  }
+}
+
+int wait2(int *retime, int *rutime, int *stime)
 {
   struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
-  
   acquire(&ptable.lock);
-  for(;;){
+  for (;;)
+  {
     // Scan through table looking for exited children.
     havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->parent != curproc)
         continue;
       havekids = 1;
-      if(p->state == ZOMBIE){
+      if (p->state == ZOMBIE)
+      {
+        //updating retime,rutime,stime of this child process
+        *retime = p->retime;
+        *rutime = p->rutime;
+        *stime = p->stime;
+
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
@@ -295,19 +373,24 @@
         p->name[0] = 0;
         p->killed = 0;
         p->state = UNUSED;
+        p->retime = 0;
+        p->rutime = 0;
+        p->ctime = 0;
+        p->stime = 0;
         release(&ptable.lock);
         return pid;
       }
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
+    if (!havekids || curproc->killed)
+    {
       release(&ptable.lock);
       return -1;
     }
 
     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    sleep(curproc, &ptable.lock); //DOC: wait-sleep
   }
 }
 
@@ -319,22 +402,26 @@
 //  - swtch to start running that process
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
-void
-scheduler(void)
+void scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
-  for(;;){
+
+  for (;;)
+  {
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+
+#ifdef DEFAULT
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->state != RUNNABLE)
         continue;
+      // cprintf("Scheduler found p=%d\n",p->pid);
 
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
@@ -342,6 +429,43 @@
       c->proc = p;
       switchuvm(p);
       p->state = RUNNING;
+      p->timeUsed = 0;
+      swtch(&(c->scheduler), p->context);
+      switchkvm();
+
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      c->proc = 0;
+    }
+
+#else
+
+#ifdef FCFS
+    struct proc *firstProc = 0;
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->state != RUNNABLE)
+        continue;
+
+      //find process with earliest ctime
+      if (firstProc == 0)
+      {
+        firstProc = p;
+      }
+      else
+      {
+        if (firstProc->ctime > p->ctime)
+        {
+          firstProc = p;
+        }
+      }
+    }
+    if (firstProc)
+    {
+      p = firstProc;
+      c->proc = p;
+      switchuvm(p);
+      p->state = RUNNING;
 
       swtch(&(c->scheduler), p->context);
       switchkvm();
@@ -350,8 +474,32 @@
       // It should have changed its p->state before coming back.
       c->proc = 0;
     }
+#else
+#if defined SML || defined DML
+  startAgain:
+    for (int priority = 3; priority >= 1; priority--) // Highest priority first
+    {
+      while (ptable.queueTails[priority - 1] > -1)
+      {
+        p = ptable.priorityLevels[priority - 1][0];
+        for (int i = 0; i < ptable.queueTails[priority - 1]; i++)
+        {
+          ptable.priorityLevels[priority - 1][i] = ptable.priorityLevels[priority - 1][i + 1];
+        }
+        ptable.queueTails[priority - 1]--;
+        c->proc = p;
+        switchuvm(p);
+        p->state = RUNNING;
+        p->timeUsed = 0;
+        swtch(&(c->scheduler), p->context);
+        switchkvm();
+        goto startAgain;
+      }
+    }
+#endif
+#endif
+#endif
     release(&ptable.lock);
-
   }
 }
 
@@ -362,19 +510,18 @@
 // be proc->intena and proc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void
-sched(void)
+void sched(void)
 {
   int intena;
   struct proc *p = myproc();
 
-  if(!holding(&ptable.lock))
+  if (!holding(&ptable.lock))
     panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
+  if (mycpu()->ncli != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if (p->state == RUNNING)
     panic("sched running");
-  if(readeflags()&FL_IF)
+  if (readeflags() & FL_IF)
     panic("sched interruptible");
   intena = mycpu()->intena;
   swtch(&p->context, mycpu()->scheduler);
@@ -382,25 +529,30 @@
 }
 
 // Give up the CPU for one scheduling round.
-void
-yield(void)
+void yield(void)
 {
-  acquire(&ptable.lock);  //DOC: yieldlock
-  myproc()->state = RUNNABLE;
+  acquire(&ptable.lock); //DOC: yieldlock
+  struct proc *p = myproc();
+  p->state = RUNNABLE;
+#if defined SML || defined DML
+  // Insert process into appropriate priority queue
+  ptable.queueTails[p->priority - 1]++;
+  ptable.priorityLevels[p->priority - 1][ptable.queueTails[p->priority - 1]] = p;
+#endif
   sched();
   release(&ptable.lock);
 }
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
-void
-forkret(void)
+void forkret(void)
 {
   static int first = 1;
   // Still holding ptable.lock from scheduler.
   release(&ptable.lock);
 
-  if (first) {
+  if (first)
+  {
     // Some initialization functions must be run in the context
     // of a regular process (e.g., they call sleep), and thus cannot
     // be run from main().
@@ -414,15 +566,13 @@
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
+void sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
-  if(p == 0)
+  if (p == 0)
     panic("sleep");
 
-  if(lk == 0)
+  if (lk == 0)
     panic("sleep without lk");
 
   // Must acquire ptable.lock in order to
@@ -431,8 +581,9 @@
   // guaranteed that we won't miss any wakeup
   // (wakeup runs with ptable.lock locked),
   // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
+  if (lk != &ptable.lock)
+  {                        //DOC: sleeplock0
+    acquire(&ptable.lock); //DOC: sleeplock1
     release(lk);
   }
   // Go to sleep.
@@ -445,7 +596,8 @@
   p->chan = 0;
 
   // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
+  if (lk != &ptable.lock)
+  { //DOC: sleeplock2
     release(&ptable.lock);
     acquire(lk);
   }
@@ -459,14 +611,25 @@
 {
   struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == SLEEPING && p->chan == chan)
+    {
+#ifdef SML
+      // Enqueue process into appropriate priority queue
+      ptable.queueTails[p->priority - 1]++;
+      ptable.priorityLevels[p->priority - 1][ptable.queueTails[p->priority - 1]] = p;
+#endif
+#ifdef DML
+      p->priority = 3; // Highest priority after returning from SLEEPING mode
+      ptable.queueTails[p->priority - 1]++;
+      ptable.priorityLevels[p->priority - 1][ptable.queueTails[p->priority - 1]] = p;
+#endif
       p->state = RUNNABLE;
+    }
 }
 
 // Wake up all processes sleeping on chan.
-void
-wakeup(void *chan)
+void wakeup(void *chan)
 {
   acquire(&ptable.lock);
   wakeup1(chan);
@@ -476,18 +639,26 @@
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
-int
-kill(int pid)
+int kill(int pid)
 {
   struct proc *p;
 
   acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)
+    {
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if (p->state == SLEEPING)
+      {
+#if defined SML || defined DML
+        // Enqueue process into appropriate priority queue
+        ptable.queueTails[p->priority - 1]++;
+        ptable.priorityLevels[p->priority - 1][ptable.queueTails[p->priority - 1]] = p;
+#endif
         p->state = RUNNABLE;
+      }
       release(&ptable.lock);
       return 0;
     }
@@ -500,35 +671,111 @@
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
+void procdump(void)
 {
   static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
+      [UNUSED] "unused",
+      [EMBRYO] "embryo",
+      [SLEEPING] "sleep ",
+      [RUNNABLE] "runble",
+      [RUNNING] "run   ",
+      [ZOMBIE] "zombie"};
   int i;
   struct proc *p;
   char *state;
   uint pc[10];
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->state == UNUSED)
       continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
       state = "???";
     cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
+    if (p->state == SLEEPING)
+    {
+      getcallerpcs((uint *)p->context->ebp + 2, pc);
+      for (i = 0; i < 10 && pc[i] != 0; i++)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
   }
 }
+
+void updateStats()
+{
+  struct proc *p;
+  acquire(&ptable.lock);
+  p = ptable.proc;
+  while (p < &ptable.proc[NPROC])
+  {
+    if (p->state == SLEEPING)
+    {
+      p->stime++;
+    }
+    else if (p->state == RUNNABLE)
+    {
+      p->retime++;
+    }
+    else if (p->state == RUNNING)
+    {
+      p->rutime++;
+    }
+    p++;
+  }
+  release(&ptable.lock);
+}
+
+// Increases time used by process. Used to check if time quanta is exhausted in trap.c
+int updateTimeUsed()
+{
+
+  int timeUsed = -1;
+  struct proc *curproc = myproc();
+  if (curproc != 0)
+  {
+    acquire(&ptable.lock);
+    curproc->timeUsed++;
+    timeUsed = curproc->timeUsed;
+    release(&ptable.lock);
+  }
+  return timeUsed;
+}
+
+// Sets process priority
+int set_prio(int priority)
+{
+  int oldPriority;
+  if (priority < 1)
+    return 1;
+  if (priority > 3)
+    return 1;
+  struct proc *curproc = myproc();
+  oldPriority = curproc->priority;
+  acquire(&ptable.lock);
+  curproc->priority = priority;
+  if (curproc->state == RUNNABLE && oldPriority != priority)
+  {
+    // Remove process from old priority queue and insert into new
+    int index = 0;
+    for (int i = 0; i <= ptable.queueTails[oldPriority - 1]; i++)
+    {
+      if (ptable.priorityLevels[oldPriority - 1][i] == curproc)
+      {
+        index = i;
+        break;
+      }
+    }
+    for (int i = index; i <= ptable.queueTails[oldPriority - 1]; i++)
+    {
+      ptable.priorityLevels[oldPriority - 1][i] = ptable.priorityLevels[oldPriority - 1][i + 1];
+    }
+    ptable.queueTails[oldPriority - 1]--;
+    ptable.queueTails[priority - 1]++;
+    ptable.priorityLevels[priority - 1][ptable.queueTails[priority - 1]] = curproc;
+  }
+  release(&ptable.lock);
+  return 0;
+}
diff -uN xv6-public/proc.h os-lab/proc.h
--- xv6-public/proc.h	2021-10-09 22:56:09.969447734 +0530
+++ os-lab/proc.h	2021-09-30 23:22:45.855750540 +0530
@@ -49,6 +49,12 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int ctime;                   // Creation time
+  int stime;                   // Time spent in sleeping state
+  int retime;                  // Time spent in ready state
+  int rutime;                  // Time spent in running state
+  int timeUsed;                // Number of ticks used from QUANTA
+  int priority;                //Priority of a process. 3 is highest 1 is lowest
 };
 
 // Process memory is laid out contiguously, low addresses first:
@@ -56,3 +62,5 @@
 //   original data and bss
 //   fixed-size stack
 //   expandable heap
+
+void updateStats();
diff -uN xv6-public/sanity.c os-lab/sanity.c
--- xv6-public/sanity.c	1970-01-01 05:30:00.000000000 +0530
+++ os-lab/sanity.c	2021-10-09 22:53:39.754583889 +0530
@@ -0,0 +1,115 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+    if (argc != 2)
+    {
+        printf(1, "Invalid input format\n");
+        exit();
+    }
+    int n = atoi(argv[1]);
+    // Fork and create children
+    for (int i = 0; i < 3 * n; i++)
+    {
+        int pid = fork();
+        if (pid == 0)
+        {                   // In child process
+            pid = getpid(); // Child process's pid
+            if (pid % 3 == 0)
+            {
+
+                // CPU Bound Process
+                for (int i = 0; i < 100; i++)
+                {
+                    double temp = 0;
+                    for (int j = 0; j < 1000000; j++)
+                    {
+                        temp += 6.42324 * 4.3121;
+                        temp -= 6.00001 * 4.812;
+                    }
+                }
+            }
+            else if (pid % 3 == 1)
+            {
+                // Short-task based CPU Bound Process
+                for (int i = 0; i < 100; i++)
+                {
+                    double temp = 0;
+                    for (int j = 0; j < 1000000; j++)
+                    {
+                        temp += 6.42324 * 4.3121;
+                        temp -= 6.00001 * 4.812;
+                    }
+                    yield();
+                }
+            }
+            else
+            {
+                // IO Bound process
+                for (int i = 0; i < 100; i++)
+                {
+                    sleep(1);
+                }
+            }
+            exit();
+        }
+    }
+    int retime, rutime, stime; // Wait , Running and Sleep (IO Wait) time
+    int sleepTime[3];
+    int readyTime[3];
+    int turnTime[3];
+    for (int i = 0; i < 3; ++i)
+    {
+        sleepTime[i] = 0;
+        readyTime[i] = 0;
+        turnTime[i] = 0;
+    }
+    // Statistics printing
+    for (int i = 0; i < 3 * n; i++)
+    {
+        // retime, rutime, stime
+        int terminatedPID = wait2(&retime, &rutime, &stime);
+        char type[10];
+        switch (terminatedPID % 3)
+        {
+        case 0:
+            sleepTime[0] += stime;
+            readyTime[0] += retime;
+            turnTime[0] += (retime + stime + rutime);
+            strcpy(type, "CPU");
+            break;
+        case 1:
+            sleepTime[1] += stime;
+            readyTime[1] += retime;
+            turnTime[1] += (retime + stime + rutime);
+            strcpy(type, "S-CPU");
+            break;
+        case 2:
+            sleepTime[2] += stime;
+            readyTime[2] += retime;
+            turnTime[2] += (retime + stime + rutime);
+            strcpy(type, "IO");
+            break;
+        }
+        printf(1, "pid = %d; Type = %s, Wait = %d, Run = %d, IO = %d\n", terminatedPID, type, retime, rutime, stime);
+    }
+    for (int i = 0; i < 3; ++i)
+    {
+        if (i == 0)
+        {
+            printf(1, "CPU:\n");
+        }
+        else if (i == 1)
+        {
+            printf(1, "S-CPU:\n");
+        }
+        else
+        {
+            printf(1, "IO:\n");
+        }
+        printf(1, "Avg Sleep Time:%d Avg Ready Time:%d Avg Turn Time:%d\n", (sleepTime[i]) / n, readyTime[i] / n, turnTime[i] / n);
+    }
+    exit();
+}
diff -uN xv6-public/SMLSanity.c os-lab/SMLSanity.c
--- xv6-public/SMLSanity.c	1970-01-01 05:30:00.000000000 +0530
+++ os-lab/SMLSanity.c	2021-10-09 22:53:49.530226438 +0530
@@ -0,0 +1,94 @@
+#include "types.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+    if (argc != 2)
+    {
+        printf(1, "Invalid input format\n");
+        exit();
+    }
+    int n = atoi(argv[1]);
+    for (int i = 0; i < 3 * n; i++)
+    {
+        int pid = fork();
+        if (pid == 0)
+        {
+            pid = getpid();
+
+            switch (pid % 3)
+            {
+            case 0:
+                set_prio(1);
+                break;
+            case 1:
+                set_prio(2);
+                break;
+            case 2:
+                set_prio(3);
+                break;
+            }
+
+            for (int k = 0; k < 100; k++)
+            {
+                for (int j = 0; j < 1000000; j++)
+                {
+                }
+            }
+            exit(); // children exit here
+        }
+    }
+
+    int retime, rutime, stime; // Wait , Running and Sleep (IO Wait) time
+    int sleepTime[3];
+    int readyTime[3];
+    int turnTime[3];
+    for (int i = 0; i < 3; ++i)
+    {
+        sleepTime[i] = 0;
+        readyTime[i] = 0;
+        turnTime[i] = 0;
+    }
+    // Statistics printing
+    for (int i = 0; i < 3 * n; i++)
+    {
+        // retime, rutime, stime
+        int terminatedPID = wait2(&retime, &rutime, &stime);
+        switch (terminatedPID % 3)
+        {
+        case 0:
+            sleepTime[0] += stime;
+            readyTime[0] += retime;
+            turnTime[0] += (retime + stime + rutime);
+            break;
+        case 1:
+            sleepTime[1] += stime;
+            readyTime[1] += retime;
+            turnTime[1] += (retime + stime + rutime);
+            break;
+        case 2:
+            sleepTime[2] += stime;
+            readyTime[2] += retime;
+            turnTime[2] += (retime + stime + rutime);
+            break;
+        }
+        //printf(1, "Priority = %d, Wait = %d, Run = %d, IO = %d\n", i+1, retime, rutime, stime);
+    }
+    for (int i = 0; i < 3; ++i)
+    {
+        if (i == 0)
+        {
+            printf(1, "Priority 1:\n");
+        }
+        else if (i == 1)
+        {
+            printf(1, "Priority 2:\n");
+        }
+        else
+        {
+            printf(1, "Priority 3:\n");
+        }
+        printf(1, "Avg Sleep Time:%d Avg Ready Time:%d Avg Turn Time:%d\n", (sleepTime[i]) / n, readyTime[i] / n, turnTime[i] / n);
+    }
+    exit();
+}
\ No newline at end of file
diff -uN xv6-public/syscall.c os-lab/syscall.c
--- xv6-public/syscall.c	2021-10-09 22:56:09.969447734 +0530
+++ os-lab/syscall.c	2021-09-30 23:22:45.855750540 +0530
@@ -14,58 +14,55 @@
 // to a saved program counter, and then the first argument.
 
 // Fetch the int at addr from the current process.
-int
-fetchint(uint addr, int *ip)
+int fetchint(uint addr, int *ip)
 {
   struct proc *curproc = myproc();
 
-  if(addr >= curproc->sz || addr+4 > curproc->sz)
+  if (addr >= curproc->sz || addr + 4 > curproc->sz)
     return -1;
-  *ip = *(int*)(addr);
+  *ip = *(int *)(addr);
   return 0;
 }
 
 // Fetch the nul-terminated string at addr from the current process.
 // Doesn't actually copy the string - just sets *pp to point at it.
 // Returns length of string, not including nul.
-int
-fetchstr(uint addr, char **pp)
+int fetchstr(uint addr, char **pp)
 {
   char *s, *ep;
   struct proc *curproc = myproc();
 
-  if(addr >= curproc->sz)
+  if (addr >= curproc->sz)
     return -1;
-  *pp = (char*)addr;
-  ep = (char*)curproc->sz;
-  for(s = *pp; s < ep; s++){
-    if(*s == 0)
+  *pp = (char *)addr;
+  ep = (char *)curproc->sz;
+  for (s = *pp; s < ep; s++)
+  {
+    if (*s == 0)
       return s - *pp;
   }
   return -1;
 }
 
 // Fetch the nth 32-bit system call argument.
-int
-argint(int n, int *ip)
+int argint(int n, int *ip)
 {
-  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+  return fetchint((myproc()->tf->esp) + 4 + 4 * n, ip);
 }
 
 // Fetch the nth word-sized system call argument as a pointer
 // to a block of memory of size bytes.  Check that the pointer
 // lies within the process address space.
-int
-argptr(int n, char **pp, int size)
+int argptr(int n, char **pp, int size)
 {
   int i;
   struct proc *curproc = myproc();
- 
-  if(argint(n, &i) < 0)
+
+  if (argint(n, &i) < 0)
     return -1;
-  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+  if (size < 0 || (uint)i >= curproc->sz || (uint)i + size > curproc->sz)
     return -1;
-  *pp = (char*)i;
+  *pp = (char *)i;
   return 0;
 }
 
@@ -73,11 +70,10 @@
 // Check that the pointer is valid and the string is nul-terminated.
 // (There is no shared writable memory, so the string can't change
 // between this check and being used by the kernel.)
-int
-argstr(int n, char **pp)
+int argstr(int n, char **pp)
 {
   int addr;
-  if(argint(n, &addr) < 0)
+  if (argint(n, &addr) < 0)
     return -1;
   return fetchstr(addr, pp);
 }
@@ -103,41 +99,51 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_history(void);
+extern int sys_wait2(void);
+extern int sys_set_prio(void);
+extern int sys_yield(void);
 
 static int (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
+    [SYS_fork] sys_fork,
+    [SYS_exit] sys_exit,
+    [SYS_wait] sys_wait,
+    [SYS_pipe] sys_pipe,
+    [SYS_read] sys_read,
+    [SYS_kill] sys_kill,
+    [SYS_exec] sys_exec,
+    [SYS_fstat] sys_fstat,
+    [SYS_chdir] sys_chdir,
+    [SYS_dup] sys_dup,
+    [SYS_getpid] sys_getpid,
+    [SYS_sbrk] sys_sbrk,
+    [SYS_sleep] sys_sleep,
+    [SYS_uptime] sys_uptime,
+    [SYS_open] sys_open,
+    [SYS_write] sys_write,
+    [SYS_mknod] sys_mknod,
+    [SYS_unlink] sys_unlink,
+    [SYS_link] sys_link,
+    [SYS_mkdir] sys_mkdir,
+    [SYS_close] sys_close,
+    [SYS_history] sys_history,
+    [SYS_wait2] sys_wait2,
+    [SYS_set_prio] sys_set_prio,
+    [SYS_yield] sys_yield,
 };
 
-void
-syscall(void)
+void syscall(void)
 {
   int num;
   struct proc *curproc = myproc();
 
   num = curproc->tf->eax;
-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+  if (num > 0 && num < NELEM(syscalls) && syscalls[num])
+  {
     curproc->tf->eax = syscalls[num]();
-  } else {
+  }
+  else
+  {
     cprintf("%d %s: unknown sys call %d\n",
             curproc->pid, curproc->name, num);
     curproc->tf->eax = -1;
diff -uN xv6-public/syscall.h os-lab/syscall.h
--- xv6-public/syscall.h	2021-10-09 22:56:09.969447734 +0530
+++ os-lab/syscall.h	2021-09-30 23:22:45.855750540 +0530
@@ -1,22 +1,26 @@
 // System call numbers
-#define SYS_fork    1
-#define SYS_exit    2
-#define SYS_wait    3
-#define SYS_pipe    4
-#define SYS_read    5
-#define SYS_kill    6
-#define SYS_exec    7
-#define SYS_fstat   8
-#define SYS_chdir   9
-#define SYS_dup    10
+#define SYS_fork 1
+#define SYS_exit 2
+#define SYS_wait 3
+#define SYS_pipe 4
+#define SYS_read 5
+#define SYS_kill 6
+#define SYS_exec 7
+#define SYS_fstat 8
+#define SYS_chdir 9
+#define SYS_dup 10
 #define SYS_getpid 11
-#define SYS_sbrk   12
-#define SYS_sleep  13
+#define SYS_sbrk 12
+#define SYS_sleep 13
 #define SYS_uptime 14
-#define SYS_open   15
-#define SYS_write  16
-#define SYS_mknod  17
+#define SYS_open 15
+#define SYS_write 16
+#define SYS_mknod 17
 #define SYS_unlink 18
-#define SYS_link   19
-#define SYS_mkdir  20
-#define SYS_close  21
+#define SYS_link 19
+#define SYS_mkdir 20
+#define SYS_close 21
+#define SYS_history 22
+#define SYS_wait2 23
+#define SYS_set_prio 24
+#define SYS_yield 25
diff -uN xv6-public/sysproc.c os-lab/sysproc.c
--- xv6-public/sysproc.c	2021-10-09 22:56:09.969447734 +0530
+++ os-lab/sysproc.c	2021-09-30 23:22:45.855750540 +0530
@@ -7,67 +7,92 @@
 #include "mmu.h"
 #include "proc.h"
 
-int
-sys_fork(void)
+int sys_fork(void)
 {
   return fork();
 }
 
-int
-sys_exit(void)
+int sys_exit(void)
 {
   exit();
-  return 0;  // not reached
+  return 0; // not reached
 }
 
-int
-sys_wait(void)
+int sys_wait(void)
 {
   return wait();
 }
 
-int
-sys_kill(void)
+int sys_wait2(void)
+{
+  int *stime;
+  int *retime;
+  int *rutime;
+  if (argptr(0, (void *)&retime, sizeof(retime)) < 0)
+    return -1;
+  if (argptr(1, (void *)&rutime, sizeof(rutime)) < 0)
+    return -1;
+  if (argptr(2, (void *)&stime, sizeof(stime)) < 0)
+    return -1;
+  return wait2(retime, rutime, stime);
+}
+
+int sys_set_prio(void)
+{
+  int priority;
+  if (argint(0, &priority) < 0)
+    return 1;
+  return set_prio(priority);
+}
+
+int sys_yield(void)
+{
+  yield();
+  // yield() doesn't fail unless ptable lock can't be acquired.
+  // This case is taken care of by XV6 panic
+  return 0;
+}
+
+int sys_kill(void)
 {
   int pid;
 
-  if(argint(0, &pid) < 0)
+  if (argint(0, &pid) < 0)
     return -1;
   return kill(pid);
 }
 
-int
-sys_getpid(void)
+int sys_getpid(void)
 {
   return myproc()->pid;
 }
 
-int
-sys_sbrk(void)
+int sys_sbrk(void)
 {
   int addr;
   int n;
 
-  if(argint(0, &n) < 0)
+  if (argint(0, &n) < 0)
     return -1;
   addr = myproc()->sz;
-  if(growproc(n) < 0)
+  if (growproc(n) < 0)
     return -1;
   return addr;
 }
 
-int
-sys_sleep(void)
+int sys_sleep(void)
 {
   int n;
   uint ticks0;
 
-  if(argint(0, &n) < 0)
+  if (argint(0, &n) < 0)
     return -1;
   acquire(&tickslock);
   ticks0 = ticks;
-  while(ticks - ticks0 < n){
-    if(myproc()->killed){
+  while (ticks - ticks0 < n)
+  {
+    if (myproc()->killed)
+    {
       release(&tickslock);
       return -1;
     }
@@ -79,8 +104,7 @@
 
 // return how many clock tick interrupts have occurred
 // since start.
-int
-sys_uptime(void)
+int sys_uptime(void)
 {
   uint xticks;
 
@@ -89,3 +113,12 @@
   release(&tickslock);
   return xticks;
 }
+
+int sys_history(void)
+{
+  char *buffer;
+  int historyId;
+  argint(1, &historyId);
+  argptr(0, &buffer, 128);
+  return history(buffer, historyId);
+}
\ No newline at end of file
diff -uN xv6-public/trap.c os-lab/trap.c
--- xv6-public/trap.c	2021-10-09 22:56:09.969447734 +0530
+++ os-lab/trap.c	2021-10-09 10:01:31.183997049 +0530
@@ -10,47 +10,51 @@
 
 // Interrupt descriptor table (shared by all CPUs).
 struct gatedesc idt[256];
-extern uint vectors[];  // in vectors.S: array of 256 entry pointers
+extern uint vectors[]; // in vectors.S: array of 256 entry pointers
 struct spinlock tickslock;
 uint ticks;
+extern int updateTimeUsed(void);
 
-void
-tvinit(void)
+void tvinit(void)
 {
   int i;
 
-  for(i = 0; i < 256; i++)
-    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+  for (i = 0; i < 256; i++)
+    SETGATE(idt[i], 0, SEG_KCODE << 3, vectors[i], 0);
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE << 3, vectors[T_SYSCALL], DPL_USER);
 
   initlock(&tickslock, "time");
 }
 
-void
-idtinit(void)
+void idtinit(void)
 {
   lidt(idt, sizeof(idt));
 }
 
 //PAGEBREAK: 41
-void
-trap(struct trapframe *tf)
+void trap(struct trapframe *tf)
 {
-  if(tf->trapno == T_SYSCALL){
-    if(myproc()->killed)
+  // cprintf("%d In trap with\n ",ticks);
+  if (tf->trapno == T_SYSCALL)
+  {
+    if (myproc()->killed)
       exit();
     myproc()->tf = tf;
     syscall();
-    if(myproc()->killed)
+    if (myproc()->killed)
       exit();
     return;
   }
 
-  switch(tf->trapno){
+  switch (tf->trapno)
+  {
   case T_IRQ0 + IRQ_TIMER:
-    if(cpuid() == 0){
+    if (cpuid() == 0)
+    {
       acquire(&tickslock);
       ticks++;
+      updateStats();
+      updateTimeUsed();
       wakeup(&ticks);
       release(&tickslock);
     }
@@ -60,7 +64,7 @@
     ideintr();
     lapiceoi();
     break;
-  case T_IRQ0 + IRQ_IDE+1:
+  case T_IRQ0 + IRQ_IDE + 1:
     // Bochs generates spurious IDE1 interrupts.
     break;
   case T_IRQ0 + IRQ_KBD:
@@ -80,7 +84,8 @@
 
   //PAGEBREAK: 13
   default:
-    if(myproc() == 0 || (tf->cs&3) == 0){
+    if (myproc() == 0 || (tf->cs & 3) == 0)
+    {
       // In kernel, it must be our mistake.
       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
               tf->trapno, cpuid(), tf->eip, rcr2());
@@ -94,19 +99,28 @@
     myproc()->killed = 1;
   }
 
-  // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running
-  // until it gets to the regular system call return.)
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit();
-
-  // Force process to give up CPU on clock tick.
-  // If interrupts were on while locks held, would need to check nlock.
-  if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
+#if defined DEFAULT || defined SML
+  // If the time for which current process held the CPU ==  QUANTA, yield()
+  int timeUsed = myproc() == 0 ? -1 : myproc()->timeUsed;
+  if (myproc() && myproc()->state == RUNNING && timeUsed == QUANTA)
     yield();
-
-  // Check if the process has been killed since we yielded
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+#else
+#ifdef DML
+  // If the time for which current process held the CPU ==  QUANTA, yield()
+  int timeUsed = myproc() == 0 ? -1 : myproc()->timeUsed;
+  if (myproc() && myproc()->state == RUNNING && timeUsed == QUANTA)
+  {
+    // Reduce priority by 1 if complete time quanta is used
+    myproc()->priority = myproc()->priority == 1 ? 1 : myproc()->priority - 1;
+    yield();
+  }
+#else
+#ifdef FCFS
+  // Do not preempt the process and hence don't call yield()
+#endif
+#endif
+#endif
+  // If current process was killed since we last yielded, it should exit()
+  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
     exit();
 }
diff -uN xv6-public/user.h os-lab/user.h
--- xv6-public/user.h	2021-10-09 22:56:09.969447734 +0530
+++ os-lab/user.h	2021-09-30 23:22:45.855750540 +0530
@@ -5,35 +5,39 @@
 int fork(void);
 int exit(void) __attribute__((noreturn));
 int wait(void);
-int pipe(int*);
-int write(int, const void*, int);
-int read(int, void*, int);
+int pipe(int *);
+int write(int, const void *, int);
+int read(int, void *, int);
 int close(int);
 int kill(int);
-int exec(char*, char**);
-int open(const char*, int);
-int mknod(const char*, short, short);
-int unlink(const char*);
-int fstat(int fd, struct stat*);
-int link(const char*, const char*);
-int mkdir(const char*);
-int chdir(const char*);
+int exec(char *, char **);
+int open(const char *, int);
+int mknod(const char *, short, short);
+int unlink(const char *);
+int fstat(int fd, struct stat *);
+int link(const char *, const char *);
+int mkdir(const char *);
+int chdir(const char *);
 int dup(int);
 int getpid(void);
-char* sbrk(int);
+char *sbrk(int);
 int sleep(int);
 int uptime(void);
+int history(char *, int);
+int wait2(int *, int *, int *);
+int set_prio(int);
+int yield(void);
 
 // ulib.c
-int stat(const char*, struct stat*);
-char* strcpy(char*, const char*);
-void *memmove(void*, const void*, int);
-char* strchr(const char*, char c);
-int strcmp(const char*, const char*);
-void printf(int, const char*, ...);
-char* gets(char*, int max);
-uint strlen(const char*);
-void* memset(void*, int, uint);
-void* malloc(uint);
-void free(void*);
-int atoi(const char*);
+int stat(const char *, struct stat *);
+char *strcpy(char *, const char *);
+void *memmove(void *, const void *, int);
+char *strchr(const char *, char c);
+int strcmp(const char *, const char *);
+void printf(int, const char *, ...);
+char *gets(char *, int max);
+uint strlen(const char *);
+void *memset(void *, int, uint);
+void *malloc(uint);
+void free(void *);
+int atoi(const char *);
diff -uN xv6-public/usys.S os-lab/usys.S
--- xv6-public/usys.S	2021-10-09 22:56:09.969447734 +0530
+++ os-lab/usys.S	2021-09-30 23:22:45.923749605 +0530
@@ -29,3 +29,7 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(history)
+SYSCALL(wait2)
+SYSCALL(set_prio)
+SYSCALL(yield)
\ No newline at end of file
diff -uN xv6-public/wait2.c os-lab/wait2.c
--- xv6-public/wait2.c	1970-01-01 05:30:00.000000000 +0530
+++ os-lab/wait2.c	2021-09-30 23:22:45.923749605 +0530
@@ -0,0 +1,23 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main()
+{
+    int i = 0;
+
+    while (i < 2)
+    {
+        i++;
+        int retime, rutime, stime;
+        fork();
+        int pid = wait2(&retime, &rutime, &stime);
+        if (pid == -1)
+        {
+            printf(1, "No terminated child found for pid = %d\n", getpid());
+            continue;
+        }
+        printf(1, "parent pid=%d, child pid:%d Retime:%d STime:%d Rutime:%d\n", getpid(), pid, retime, stime, rutime);
+    }
+    exit();
+}
